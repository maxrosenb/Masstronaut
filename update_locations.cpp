#include <unistd.h>
#include <ios>
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <chrono>
#include <fstream>
#include <string>
#include <random>


void process_mem_usage(double& vm_usage, double& resident_set)
{
   using std::ios_base;
   using std::ifstream;
   using std::string;

   vm_usage     = 0.0;
   resident_set = 0.0; 

   // 'file' stat seems to give the most reliable results
   //
   ifstream stat_stream("/proc/self/stat",ios_base::in);

   // dummy vars for leading entries in stat that we don't care about
   //
   string pid, comm, state, ppid, pgrp, session, tty_nr;
   string tpgid, flags, minflt, cminflt, majflt, cmajflt;
   string utime, stime, cutime, cstime, priority, nice;
   string O, itrealvalue, starttime;

   // the two fields we want
   //
   unsigned long vsize;
   long rss;

   stat_stream >> pid >> comm >> state >> ppid >> pgrp >> session >> tty_nr
               >> tpgid >> flags >> minflt >> cminflt >> majflt >> cmajflt
               >> utime >> stime >> cutime >> cstime >> priority >> nice
               >> O >> itrealvalue >> starttime >> vsize >> rss; // don't care about the rest

   stat_stream.close();

   long page_size_kb = sysconf(_SC_PAGE_SIZE) / 1024; // in case x86-64 is configured to use 2MB pages
   vm_usage     = vsize / 1024.0;
   resident_set = rss * page_size_kb;
}

float * generate_random_list(int size, float bound) {

	const float LO = -1 * bound;
	const float HI =  bound;

	float* vals = new float[size];

	std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(LO, HI);
    for (int n = 0; n < size; ++n) {
        // Use dis to transform the random unsigned int generated by gen into a 
        // double in [1, 2). Each call to dis(gen) generates a new random double
        vals[n] = static_cast<float> (dis(gen));
    }

	return vals;
}

void update_coords(int size, float *xs, float *ys, float *zs, float *vx, float *vy, float *vz) {
	for(int i=0; i<size; i++)
	{
		xs[i] = xs[i] + vx[i];
		ys[i] = ys[i] + vy[i];
		zs[i] = zs[i] + vz[i];
	}
}

float sum_coords(float *xs, int size){

	float sum = 0;
	for(int i = 0; i<size; i++)
	{
		sum += xs[i];
	}
	return sum;
}

int main()
{
	using namespace std;
	double vm, rss;
	int size;
	int iters;
	float chksum;
	float mean_time_per_coordinate;



	const float COORD_BOUND = 1000.0;
	const float VELOC_BOUND = 1.0;
	cout << "Please enter the number of objects: ";
	cin >> size;
	cout << "Please enter the number of iterations: ";
	cin >> iters;
	srand(size*iters);
	float *xs = generate_random_list(size,COORD_BOUND);
	float *ys = generate_random_list(size,COORD_BOUND);
	float *zs = generate_random_list(size,COORD_BOUND);
	float *vx = generate_random_list(size,VELOC_BOUND);
	float *vy = generate_random_list(size,VELOC_BOUND);
	float *vz = generate_random_list(size,VELOC_BOUND);

	chksum = sum_coords(xs, size);
	auto t1 = chrono::high_resolution_clock::now();

	int i;
	for(i=0; i<iters; i++)
	{
		update_coords(size, xs, ys, zs, vx, vy, vz);
	}
	
	auto t2 = chrono::high_resolution_clock::now();

	auto duration = chrono::duration_cast<chrono::microseconds>( t2-t1 ).count();
	mean_time_per_coordinate = static_cast<float> (duration) / ((size * iters));
	process_mem_usage(vm, rss);
	cout << "mean team per coordinate: ";
	cout << mean_time_per_coordinate;
	cout << "us";
	cout << "\n";
	cout << "chechksum: ";
	cout << chksum;
	cout << " size: ";
	cout << size;
	cout << " iters: ";
	cout << iters;
	cout << "\n";
	cout << "VM: " << vm << "; RSS: " << rss << endl;



	
	delete[] xs;
	delete[] ys;
	delete[] zs;
	delete[] vx;
	delete[] vy;
	delete[] vz;
		
	return 0;
}